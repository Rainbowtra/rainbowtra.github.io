<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>福音橋佈道動畫</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            background-color: #f0f0f0;
            color: #333;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        
        #container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        #canvas-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        #ui-container {
            position: absolute;
            bottom: 0;
            width: 100%;
            padding: 20px;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            color: white;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stage-title {
            font-size: 24px;
            margin-bottom: 15px;
            text-align: center;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            transition: all 0.3s;
        }
        
        .stage-description {
            font-size: 18px;
            text-align: center;
            margin-bottom: 20px;
            max-width: 800px;
            line-height: 1.5;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
            transition: all 0.3s;
        }
        
        .large-text {
            font-size: 32px !important;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 15px;
        }
        
        .control-btn {
            padding: 12px 24px;
            font-size: 18px;
            background-color: #4a6fa5;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            min-width: 150px;
        }
        
        .control-btn:hover {
            background-color: #5a8fd8;
            transform: translateY(-2px);
        }
        
        .control-btn:active {
            transform: translateY(1px);
        }
        
        .special-controls {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }
        
        .toggle-btn {
            background-color: #2e7d32;
        }
        
        .reset-btn {
            background-color: #c62828;
        }
        
        .stage-indicator {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .stage-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: rgba(255,255,255,0.5);
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .stage-dot.active {
            background-color: #FFD700;
            transform: scale(1.3);
        }
        
        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            max-width: 250px;
            font-size: 16px;
            line-height: 1.4;
            z-index: 5;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border-radius: 4px;
        }
        
        @media (max-width: 768px) {
            .stage-title {
                font-size: 20px;
            }
            
            .stage-description {
                font-size: 16px;
            }
            
            .control-btn {
                padding: 10px 15px;
                font-size: 16px;
                min-width: 120px;
            }
            
            .legend {
                position: relative;
                top: auto;
                right: auto;
                width: 90%;
                margin: 10px auto;
                max-width: none;
            }
            
            .large-text {
                font-size: 26px !important;
            }
        }
        
        @media (max-width: 480px) {
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .control-btn {
                width: 90%;
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
</head>
<body>
    <div id="container">
        <div id="canvas-container"></div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background-color: #4a6fa5;"></div>
                <div>人的世界 (城市、道路)</div>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #2e7d32;"></div>
                <div>上帝的世界 (生命樹、光明)</div>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #c62828;"></div>
                <div>斷裂的橋 (罪與死亡的分隔)</div>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #FFD700;"></div>
                <div>十字架 (連接兩邊的橋樑)</div>
            </div>
        </div>
        
        <div id="ui-container">
            <div id="stage-title" class="stage-title">第一階段：神起初創造</div>
            <div id="stage-description" class="stage-description">神創造了完美的世界，人與神有著美好的關係。</div>
            
            <div class="controls">
                <button id="prev-btn" class="control-btn">上一步</button>
                <button id="play-btn" class="control-btn">播放動畫</button>
                <button id="next-btn" class="control-btn">下一步</button>
            </div>
            
            <div class="special-controls">
                <button id="large-text-btn" class="control-btn toggle-btn">開啟大字版</button>
                <button id="reset-btn" class="control-btn reset-btn">重新開始</button>
            </div>
            
            <div class="stage-indicator">
                <div class="stage-dot active" data-stage="1"></div>
                <div class="stage-dot" data-stage="2"></div>
                <div class="stage-dot" data-stage="3"></div>
                <div class="stage-dot" data-stage="4"></div>
                <div class="stage-dot" data-stage="5"></div>
            </div>
        </div>
    </div>

    <script>
        // 應用程序狀態
        const AppState = {
            currentStage: 1,
            totalStages: 5,
            isPlaying: false,
            largeTextMode: false,
            animationInProgress: false
        };
        
        // 3D場景元素
        let scene, camera, renderer, controls;
        let worldLeft, worldRight, brokenBridge, crossBridge, humanFigure;
        let stageLights = {};
        let rainParticles = [];
        
        // 初始化Three.js場景
        function init() {
            // 創建場景
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 10, 100);
            
            // 創建相機
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 20);
            
            // 創建渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // 添加軌道控制
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 50;
            controls.maxPolarAngle = Math.PI / 2 - 0.1;
            
            // 添加燈光
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -30;
            directionalLight.shadow.camera.right = 30;
            directionalLight.shadow.camera.top = 30;
            directionalLight.shadow.camera.bottom = -30;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // 為每個階段創建聚光燈
            for (let i = 1; i <= 5; i++) {
                stageLights[i] = new THREE.SpotLight(0xffffff, 1);
                stageLights[i].position.set(0, 20, 0);
                stageLights[i].angle = Math.PI / 3;
                stageLights[i].penumbra = 0.5;
                stageLights[i].decay = 2;
                stageLights[i].distance = 100;
                stageLights[i].castShadow = true;
                stageLights[i].visible = false;
                scene.add(stageLights[i]);
            }
            
            // 創建場景元素
            createWorlds();
            createBrokenBridge();
            createCrossBridge();
            createHumanFigure();
            createRainEffect();
            
            // 初始設置為第一階段
            setStage(1);
            
            // 開始動畫循環
            animate();
            
            // 添加窗口大小調整監聽
            window.addEventListener('resize', onWindowResize);
        }
        
        // 創建人的世界（左側）和上帝的世界（右側）
        function createWorlds() {
            // 人的世界 - 城市
            worldLeft = new THREE.Group();
            
            // 地面
            const groundGeometry = new THREE.PlaneGeometry(40, 30);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x4a6fa5, side: THREE.DoubleSide });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.set(-20, -1, 0);
            ground.receiveShadow = true;
            worldLeft.add(ground);
            
            // 道路
            const roadGeometry = new THREE.PlaneGeometry(5, 30);
            const roadMaterial = new THREE.MeshLambertMaterial({ color: 0x666666, side: THREE.DoubleSide });
            const road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.rotation.x = -Math.PI / 2;
            road.position.set(-20, -0.9, 0);
            road.receiveShadow = true;
            worldLeft.add(road);
            
            // 創建建築物
            const buildingColors = [0x8B4513, 0xA0522D, 0xCD853F, 0xD2691E];
            for (let i = 0; i < 8; i++) {
                const width = 2 + Math.random() * 3;
                const height = 3 + Math.random() * 8;
                const depth = 2 + Math.random() * 3;
                
                const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                const buildingMaterial = new THREE.MeshLambertMaterial({ 
                    color: buildingColors[Math.floor(Math.random() * buildingColors.length)] 
                });
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.castShadow = true;
                building.receiveShadow = true;
                
                building.position.set(
                    -30 + Math.random() * 20,
                    height / 2 - 1,
                    -10 + Math.random() * 20
                );
                
                worldLeft.add(building);
            }
            
            // 上帝的世界 - 伊甸園
            worldRight = new THREE.Group();
            
            // 地面
            const gardenGroundGeometry = new THREE.PlaneGeometry(40, 30);
            const gardenGroundMaterial = new THREE.MeshLambertMaterial({ color: 0x2e7d32, side: THREE.DoubleSide });
            const gardenGround = new THREE.Mesh(gardenGroundGeometry, gardenGroundMaterial);
            gardenGround.rotation.x = -Math.PI / 2;
            gardenGround.position.set(20, -1, 0);
            gardenGround.receiveShadow = true;
            worldRight.add(gardenGround);
            
            // 生命樹
            const treeGroup = new THREE.Group();
            
            // 樹幹
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.8, 8, 8);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            treeGroup.add(trunk);
            
            // 樹冠
            const treeCrownGeometry = new THREE.SphereGeometry(4, 8, 8);
            const treeCrownMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const treeCrown = new THREE.Mesh(treeCrownGeometry, treeCrownMaterial);
            treeCrown.position.y = 5;
            treeCrown.castShadow = true;
            treeGroup.add(treeCrown);
            
            // 果實
            const fruitGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const fruitMaterial = new THREE.MeshLambertMaterial({ color: 0xFF4500 });
            for (let i = 0; i < 20; i++) {
                const fruit = new THREE.Mesh(fruitGeometry, fruitMaterial);
                fruit.position.set(
                    (Math.random() - 0.5) * 6,
                    3 + Math.random() * 4,
                    (Math.random() - 0.5) * 6
                );
                treeGroup.add(fruit);
            }
            
            treeGroup.position.set(20, 0, 0);
            worldRight.add(treeGroup);
            
            // 添加花朵
            const flowerGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const flowerMaterial = new THREE.MeshLambertMaterial({ color: 0xFF69B4 });
            for (let i = 0; i < 30; i++) {
                const flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
                flower.position.set(
                    5 + Math.random() * 30,
                    -0.8,
                    -12 + Math.random() * 24
                );
                worldRight.add(flower);
            }
            
            scene.add(worldLeft);
            scene.add(worldRight);
        }
        
        // 創建斷裂的橋
        function createBrokenBridge() {
            brokenBridge = new THREE.Group();
            
            // 左側橋段
            const leftBridgeGeometry = new THREE.BoxGeometry(10, 0.5, 3);
            const leftBridgeMaterial = new THREE.MeshLambertMaterial({ color: 0xc62828 });
            const leftBridge = new THREE.Mesh(leftBridgeGeometry, leftBridgeMaterial);
            leftBridge.position.set(-5, 0, 0);
            leftBridge.castShadow = true;
            leftBridge.receiveShadow = true;
            brokenBridge.add(leftBridge);
            
            // 右側橋段
            const rightBridgeGeometry = new THREE.BoxGeometry(10, 0.5, 3);
            const rightBridgeMaterial = new THREE.MeshLambertMaterial({ color: 0xc62828 });
            const rightBridge = new THREE.Mesh(rightBridgeGeometry, rightBridgeMaterial);
            rightBridge.position.set(5, 0, 0);
            rightBridge.castShadow = true;
            rightBridge.receiveShadow = true;
            brokenBridge.add(rightBridge);
            
            // 斷裂處的間隙
            const gapGeometry = new THREE.BoxGeometry(2, 2, 3.2);
            const gapMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            const gap = new THREE.Mesh(gapGeometry, gapMaterial);
            gap.position.set(0, -1, 0);
            brokenBridge.add(gap);
            
            scene.add(brokenBridge);
        }
        
        // 創建十字架橋樑
        function createCrossBridge() {
            crossBridge = new THREE.Group();
            crossBridge.visible = false;
            
            // 十字架豎立部分
            const verticalGeometry = new THREE.BoxGeometry(1, 10, 1);
            const verticalMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
            const verticalBeam = new THREE.Mesh(verticalGeometry, verticalMaterial);
            verticalBeam.position.set(0, 5, 0);
            verticalBeam.castShadow = true;
            verticalBeam.receiveShadow = true;
            crossBridge.add(verticalBeam);
            
            // 十字架橫向部分
            const horizontalGeometry = new THREE.BoxGeometry(10, 1, 1);
            const horizontalMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
            const horizontalBeam = new THREE.Mesh(horizontalGeometry, horizontalMaterial);
            horizontalBeam.position.set(0, 8, 0);
            horizontalBeam.castShadow = true;
            horizontalBeam.receiveShadow = true;
            crossBridge.add(horizontalBeam);
            
            // 橋面
            const bridgeGeometry = new THREE.BoxGeometry(12, 0.3, 3);
            const bridgeMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700, transparent: true, opacity: 0.7 });
            const bridge = new THREE.Mesh(bridgeGeometry, bridgeMaterial);
            bridge.position.set(0, 0, 0);
            bridge.castShadow = true;
            bridge.receiveShadow = true;
            crossBridge.add(bridge);
            
            scene.add(crossBridge);
        }
        
        // 創建人物模型
        function createHumanFigure() {
            humanFigure = new THREE.Group();
            
            // 頭部
            const headGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFE4B5 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.5;
            head.castShadow = true;
            humanFigure.add(head);
            
            // 身體
            const bodyGeometry = new THREE.BoxGeometry(1, 1.5, 0.5);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x4682B4 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            humanFigure.add(body);
            
            // 腿部
            const legGeometry = new THREE.BoxGeometry(0.3, 1, 0.3);
            const legMaterial = new THREE.MeshLambertMaterial({ color: 0x2F4F4F });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.2, -0.5, 0);
            leftLeg.castShadow = true;
            humanFigure.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.2, -0.5, 0);
            rightLeg.castShadow = true;
            humanFigure.add(rightLeg);
            
            // 手臂
            const armGeometry = new THREE.BoxGeometry(0.3, 1.2, 0.3);
            const armMaterial = new THREE.MeshLambertMaterial({ color: 0x4682B4 });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.8, 0.8, 0);
            leftArm.castShadow = true;
            humanFigure.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.8, 0.8, 0);
            rightArm.castShadow = true;
            humanFigure.add(rightArm);
            
            // 初始位置在人的世界
            humanFigure.position.set(-15, 0, 0);
            scene.add(humanFigure);
        }
        
        // 創建下雨效果
        function createRainEffect() {
            const rainGeometry = new THREE.BufferGeometry();
            const rainCount = 1000;
            const positions = new Float32Array(rainCount * 3);
            
            for (let i = 0; i < rainCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 50;     // x
                positions[i + 1] = Math.random() * 30;        // y
                positions[i + 2] = (Math.random() - 0.5) * 30; // z
            }
            
            rainGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const rainMaterial = new THREE.PointsMaterial({
                color: 0xAAAAFF,
                size: 0.1,
                transparent: true
            });
            
            const rain = new THREE.Points(rainGeometry, rainMaterial);
            rain.visible = false;
            scene.add(rain);
            
            rainParticles.push(rain);
        }
        
        // 設置當前階段
        function setStage(stage) {
            if (AppState.animationInProgress || stage < 1 || stage > AppState.totalStages) return;
            
            AppState.currentStage = stage;
            AppState.animationInProgress = true;
            
            // 更新UI
            updateStageUI();
            
            // 根據階段設置場景
            switch(stage) {
                case 1: // 神起初創造
                    setStage1();
                    break;
                case 2: // 人犯罪墜落
                    setStage2();
                    break;
                case 3: // 人無力自救
                    setStage3();
                    break;
                case 4: // 神差遣耶穌
                    setStage4();
                    break;
                case 5: // 救主耶穌復活
                    setStage5();
                    break;
            }
            
            // 更新階段指示器
            updateStageIndicator();
            
            // 完成動畫
            setTimeout(() => {
                AppState.animationInProgress = false;
            }, 1500);
        }
        
        function setStage1() {
            // 明亮、溫暖的色調
            scene.fog.color.setHex(0x87CEEB);
            scene.background = new THREE.Color(0x87CEEB);
            
            // 人的世界和上帝的世界都明亮
            worldLeft.children.forEach(child => {
                if (child.material) {
                    child.material.color.setHex(0x4a6fa5);
                }
            });
            
            worldRight.children.forEach(child => {
                if (child.material) {
                    if (child.material.color.getHex() === 0x2e7d32) {
                        child.material.color.setHex(0x2e7d32);
                    }
                }
            });
            
            // 斷裂的橋不可見
            brokenBridge.visible = false;
            
            // 十字架橋樑不可見
            crossBridge.visible = false;
            
            // 人物在伊甸園中
            humanFigure.position.set(5, 0, 0);
            
            // 下雨效果關閉
            rainParticles.forEach(rain => rain.visible = false);
            
            // 階段燈光
            Object.keys(stageLights).forEach(key => {
                stageLights[key].visible = false;
            });
            stageLights[1].visible = true;
            stageLights[1].color.setHex(0xFFD700);
        }
        
        function setStage2() {
            // 陰暗的色調
            scene.fog.color.setHex(0x333333);
            scene.background = new THREE.Color(0x333333);
            
            // 人的世界變得陰暗
            worldLeft.children.forEach(child => {
                if (child.material) {
                    const currentColor = child.material.color.getHex();
                    if (currentColor === 0x4a6fa5) {
                        child.material.color.setHex(0x2a4a75);
                    }
                }
            });
            
            // 斷裂的橋可見並搖擺
            brokenBridge.visible = true;
            animateBrokenBridge();
            
            // 十字架橋樑不可見
            crossBridge.visible = false;
            
            // 人物在人的世界
            humanFigure.position.set(-15, 0, 0);
            
            // 下雨效果開啟
            rainParticles.forEach(rain => rain.visible = true);
            
            // 階段燈光
            Object.keys(stageLights).forEach(key => {
                stageLights[key].visible = false;
            });
            stageLights[2].visible = true;
            stageLights[2].color.setHex(0x555555);
        }
        
        function setStage3() {
            // 保持陰暗色調
            scene.fog.color.setHex(0x333333);
            scene.background = new THREE.Color(0x333333);
            
            // 斷裂的橋保持可見
            brokenBridge.visible = true;
            
            // 十字架橋樑不可見
            crossBridge.visible = false;
            
            // 人物試圖跨越但失敗
            humanFigure.position.set(-5, 0, 0);
            
            // 下雨效果持續
            rainParticles.forEach(rain => rain.visible = true);
            
            // 階段燈光
            Object.keys(stageLights).forEach(key => {
                stageLights[key].visible = false;
            });
            stageLights[3].visible = true;
            stageLights[3].color.setHex(0x666666);
        }
        
        function setStage4() {
            // 開始變亮
            scene.fog.color.setHex(0x6699CC);
            scene.background = new THREE.Color(0x6699CC);
            
            // 斷裂的橋仍然可見
            brokenBridge.visible = true;
            
            // 十字架橋樑可見
            crossBridge.visible = true;
            crossBridge.position.y = -5;
            
            // 動畫：十字架升起
            animateCrossBridge();
            
            // 人物在十字架前
            humanFigure.position.set(-5, 0, 0);
            
            // 下雨效果減弱
            rainParticles.forEach(rain => {
                rain.material.opacity = 0.3;
                rain.visible = true;
            });
            
            // 階段燈光
            Object.keys(stageLights).forEach(key => {
                stageLights[key].visible = false;
            });
            stageLights[4].visible = true;
            stageLights[4].color.setHex(0xFFA500);
        }
        
        function setStage5() {
            // 明亮、榮耀的色調
            scene.fog.color.setHex(0x87CEEB);
            scene.background = new THREE.Color(0x87CEEB);
            
            // 斷裂的橋不可見
            brokenBridge.visible = false;
            
            // 十字架橋樑發光
            crossBridge.visible = true;
            crossBridge.position.y = 0;
            
            // 人物通過十字架走到上帝的世界
            humanFigure.position.set(15, 0, 0);
            
            // 下雨效果關閉
            rainParticles.forEach(rain => rain.visible = false);
            
            // 上帝的世界特別明亮
            worldRight.children.forEach(child => {
                if (child.material) {
                    if (child.material.color.getHex() === 0x2e7d32) {
                        child.material.color.setHex(0x3CB371);
                    }
                }
            });
            
            // 階段燈光
            Object.keys(stageLights).forEach(key => {
                stageLights[key].visible = false;
            });
            stageLights[5].visible = true;
            stageLights[5].color.setHex(0xFFFFFF);
            
            // 添加榮光效果
            addGloryEffect();
        }
        
        // 動畫：斷裂的橋搖擺
        function animateBrokenBridge() {
            const leftPart = brokenBridge.children[0];
            const rightPart = brokenBridge.children[1];
            
            const startTime = Date.now();
            const duration = 2000;
            
            function animate() {
                const elapsed = Date.now() - startTime;
                if (elapsed < duration) {
                    const progress = elapsed / duration;
                    const angle = Math.sin(progress * Math.PI * 4) * 0.2;
                    
                    leftPart.rotation.z = angle;
                    rightPart.rotation.z = -angle;
                    
                    requestAnimationFrame(animate);
                } else {
                    leftPart.rotation.z = 0;
                    rightPart.rotation.z = 0;
                }
            }
            
            animate();
        }
        
        // 動畫：十字架升起
        function animateCrossBridge() {
            const startY = crossBridge.position.y;
            const targetY = 0;
            const startTime = Date.now();
            const duration = 2000;
            
            function animate() {
                const elapsed = Date.now() - startTime;
                if (elapsed < duration) {
                    const progress = elapsed / duration;
                    const newY = startY + (targetY - startY) * progress;
                    crossBridge.position.y = newY;
                    
                    requestAnimationFrame(animate);
                } else {
                    crossBridge.position.y = targetY;
                }
            }
            
            animate();
        }
        
        // 添加榮光效果
        function addGloryEffect() {
            const gloryGeometry = new THREE.SphereGeometry(10, 16, 16);
            const gloryMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFF00,
                transparent: true,
                opacity: 0.3
            });
            const glory = new THREE.Mesh(gloryGeometry, gloryMaterial);
            glory.position.set(20, 5, 0);
            scene.add(glory);
            
            // 使榮光脈動
            let pulseDirection = 1;
            let pulseScale = 1;
            
            function pulse() {
                pulseScale += 0.01 * pulseDirection;
                if (pulseScale > 1.2) pulseDirection = -1;
                if (pulseScale < 0.9) pulseDirection = 1;
                
                glory.scale.set(pulseScale, pulseScale, pulseScale);
                requestAnimationFrame(pulse);
            }
            
            pulse();
        }
        
        // 更新階段UI
        function updateStageUI() {
            const titles = [
                "第一階段：神起初創造",
                "第二階段：人犯罪墜落",
                "第三階段：人無力自救",
                "第四階段：神差遣耶穌",
                "第五階段：救主耶穌復活"
            ];
            
            const descriptions = [
                "神創造了完美的世界，人與神有著美好的關係。",
                "人犯罪違背神，導致與神的關係決裂，帶來死亡與分隔。",
                "人無法靠自己的努力修復與神的關係，世界充滿痛苦與罪惡。",
                "神差遣祂的兒子耶穌基督，為我們的罪釘死在十字架上。",
                "耶穌從死裡復活，戰勝死亡！藉著十字架，我們可以與神和好，回到神永恆的家中。"
            ];
            
            const titleElement = document.getElementById('stage-title');
            const descriptionElement = document.getElementById('stage-description');
            
            titleElement.textContent = titles[AppState.currentStage - 1];
            descriptionElement.textContent = descriptions[AppState.currentStage - 1];
            
            // 應用大字版設置
            if (AppState.largeTextMode) {
                titleElement.classList.add('large-text');
                descriptionElement.classList.add('large-text');
            } else {
                titleElement.classList.remove('large-text');
                descriptionElement.classList.remove('large-text');
            }
        }
        
        // 更新階段指示器
        function updateStageIndicator() {
            const dots = document.querySelectorAll('.stage-dot');
            dots.forEach((dot, index) => {
                if (index + 1 === AppState.currentStage) {
                    dot.classList.add('active');
                } else {
                    dot.classList.remove('active');
                }
            });
        }
        
        // 播放動畫序列
        function playAnimationSequence() {
            if (AppState.isPlaying || AppState.animationInProgress) return;
            
            AppState.isPlaying = true;
            document.getElementById('play-btn').textContent = '播放中...';
            
            let currentStage = 1;
            
            function playNextStage() {
                if (currentStage <= AppState.totalStages) {
                    setStage(currentStage);
                    currentStage++;
                    
                    if (currentStage <= AppState.totalStages) {
                        setTimeout(playNextStage, 3000);
                    } else {
                        // 動畫結束
                        AppState.isPlaying = false;
                        document.getElementById('play-btn').textContent = '播放動畫';
                    }
                }
            }
            
            playNextStage();
        }
        
        // 切換大字版
        function toggleLargeText() {
            AppState.largeTextMode = !AppState.largeTextMode;
            const button = document.getElementById('large-text-btn');
            
            if (AppState.largeTextMode) {
                button.textContent = '關閉大字版';
                document.querySelectorAll('.stage-title, .stage-description').forEach(el => {
                    el.classList.add('large-text');
                });
            } else {
                button.textContent = '開啟大字版';
                document.querySelectorAll('.stage-title, .stage-description').forEach(el => {
                    el.classList.remove('large-text');
                });
            }
            
            // 更新當前階段UI以應用變化
            updateStageUI();
        }
        
        // 重置動畫
        function resetAnimation() {
            AppState.currentStage = 1;
            AppState.isPlaying = false;
            AppState.animationInProgress = false;
            
            document.getElementById('play-btn').textContent = '播放動畫';
            setStage(1);
        }
        
        // 處理窗口大小變化
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 動畫循環
        function animate() {
            requestAnimationFrame(animate);
            
            // 更新下雨效果
            rainParticles.forEach(rain => {
                if (rain.visible) {
                    const positions = rain.geometry.attributes.position.array;
                    for (let i = 1; i < positions.length; i += 3) {
                        positions[i] -= 0.2; // 雨滴下落
                        if (positions[i] < -5) {
                            positions[i] = 20; // 重置到頂部
                        }
                    }
                    rain.geometry.attributes.position.needsUpdate = true;
                }
            });
            
            // 更新控制
            controls.update();
            
            // 渲染場景
            renderer.render(scene, camera);
        }
        
        // 初始化UI事件監聽
        function initUIEvents() {
            // 上一步按鈕
            document.getElementById('prev-btn').addEventListener('click', () => {
                if (AppState.currentStage > 1 && !AppState.animationInProgress) {
                    setStage(AppState.currentStage - 1);
                }
            });
            
            // 播放動畫按鈕
            document.getElementById('play-btn').addEventListener('click', () => {
                if (!AppState.animationInProgress) {
                    playAnimationSequence();
                }
            });
            
            // 下一步按鈕
            document.getElementById('next-btn').addEventListener('click', () => {
                if (AppState.currentStage < AppState.totalStages && !AppState.animationInProgress) {
                    setStage(AppState.currentStage + 1);
                }
            });
            
            // 大字版切換按鈕
            document.getElementById('large-text-btn').addEventListener('click', toggleLargeText);
            
            // 重置按鈕
            document.getElementById('reset-btn').addEventListener('click', resetAnimation);
            
            // 階段指示器點擊
            document.querySelectorAll('.stage-dot').forEach(dot => {
                dot.addEventListener('click', () => {
                    const stage = parseInt(dot.getAttribute('data-stage'));
                    if (!AppState.animationInProgress) {
                        setStage(stage);
                    }
                });
            });
            
            // 鍵盤控制
            document.addEventListener('keydown', (e) => {
                if (AppState.animationInProgress) return;
                
                switch(e.key) {
                    case 'ArrowLeft':
                        if (AppState.currentStage > 1) {
                            setStage(AppState.currentStage - 1);
                        }
                        break;
                    case 'ArrowRight':
                        if (AppState.currentStage < AppState.totalStages) {
                            setStage(AppState.currentStage + 1);
                        }
                        break;
                    case ' ':
                        playAnimationSequence();
                        break;
                    case 'r':
                    case 'R':
                        resetAnimation();
                        break;
                }
            });
        }
        
        // 頁面加載完成後初始化
        window.addEventListener('DOMContentLoaded', () => {
            init();
            initUIEvents();
        });
    </script>
</body>
</html>
